<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Spatial4n.Core</name>
    </assembly>
    <members>
        <member name="T:Spatial4n.Core.Context.SpatialContext">
            <summary>
            This is a facade to most of Spatial4n, holding things like <see cref="T:Spatial4n.Core.Distance.IDistanceCalculator"/>, 
            <see cref="P:Spatial4n.Core.Context.SpatialContext.WktShapeParser"/>, and acting as a factory for the <see cref="T:Spatial4n.Core.Shapes.IShape"/>s.
            <para>
            If you want a typical geodetic context, just reference <see cref="F:Spatial4n.Core.Context.SpatialContext.GEO"/>.  Otherwise,
            You should either create and configure a <see cref="T:Spatial4n.Core.Context.SpatialContextFactory"/> and then call
            <see cref="M:Spatial4n.Core.Context.SpatialContextFactory.NewSpatialContext"/>, OR, call
            <see cref="M:Spatial4n.Core.Context.SpatialContextFactory.MakeSpatialContext(System.Collections.Generic.IDictionary{System.String,System.String})"/>
            to do this via configuration data.
            </para>
            Thread-safe &amp; immutable.
            </summary>
        </member>
        <member name="F:Spatial4n.Core.Context.SpatialContext.GEO">
            <summary>
            A popular default SpatialContext implementation for geospatial.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.#ctor(System.Boolean,Spatial4n.Core.Distance.IDistanceCalculator,Spatial4n.Core.Shapes.IRectangle)">
            <summary>
            Consider using <see cref="T:Spatial4n.Core.Context.SpatialContextFactory"/> instead.
            </summary>
            <param name="geo">Establishes geo vs cartesian / Euclidean.</param>
            <param name="calculator">Optional; defaults to Haversine or cartesian depending on units.</param>
            <param name="worldBounds">Optional; defaults to GEO_WORLDBOUNDS or MAX_WORLDBOUNDS depending on units.</param> 
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.#ctor(Spatial4n.Core.Context.SpatialContextFactory)">
            <summary>
            Called by <see cref="M:Spatial4n.Core.Context.SpatialContextFactory.NewSpatialContext"/>.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.CalcDistance(Spatial4n.Core.Shapes.IPoint,System.Double,System.Double)">
            <summary>
            Convenience that uses <see cref="P:Spatial4n.Core.Context.SpatialContext.DistCalc"/>
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.CalcDistance(Spatial4n.Core.Shapes.IPoint,Spatial4n.Core.Shapes.IPoint)">
            <summary>
            Convenience that uses <see cref="P:Spatial4n.Core.Context.SpatialContext.DistCalc"/>
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Context.SpatialContext.WorldBounds">
            <summary>
            The extent of x &amp; y coordinates should fit within the return'ed rectangle.
            Do *NOT* invoke <see cref="M:Spatial4n.Core.Shapes.IRectangle.Reset(System.Double,System.Double,System.Double,System.Double)"/> on this return type.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Spatial4n.Core.Context.SpatialContext.IsNormWrapLongitude">
            <summary>
            If true then <see cref="M:Spatial4n.Core.Context.SpatialContext.NormX(System.Double)"/> will wrap longitudes outside of the standard
            geodetic boundary into it. Example: 181 will become -179.
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Context.SpatialContext.IsGeo">
            <summary>
            Is the mathematical world model based on a sphere, or is it a flat plane? The word
            "geodetic" or "geodesic" is sometimes used to refer to the former, and the latter is sometimes
            referred to as "Euclidean" or "cartesian".
            </summary>
            <returns></returns>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.NormX(System.Double)">
            <summary>
            Normalize the 'x' dimension. Might reduce precision or wrap it to be within the bounds. This
            is called by <see cref="T:Spatial4n.Core.IO.WktShapeParser"/> before creating a shape.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.NormY(System.Double)">
            <summary>
            Normalize the 'y' dimension. Might reduce precision or wrap it to be within the bounds. This
            is called by <see cref="T:Spatial4n.Core.IO.WktShapeParser"/> before creating a shape.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.VerifyX(System.Double)">
            <summary>
            Ensure fits in <see cref="P:Spatial4n.Core.Context.SpatialContext.WorldBounds"/>. It's called by any shape factory method that
            gets an 'x' dimension.
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.VerifyY(System.Double)">
            <summary>
            Ensure fits in <see cref="P:Spatial4n.Core.Context.SpatialContext.WorldBounds"/>. It's called by any shape factory method that
            gets a 'y' dimension.
            </summary>
            <param name="y"></param>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.MakePoint(System.Double,System.Double)">
            <summary>
            Construct a point.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.MakeRectangle(Spatial4n.Core.Shapes.IPoint,Spatial4n.Core.Shapes.IPoint)">
            <summary>
            Construct a rectangle.
            </summary>
            <param name="lowerLeft"></param>
            <param name="upperRight"></param>
            <returns></returns>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.MakeRectangle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Construct a rectangle. If just one longitude is on the dateline (+/- 180)
            then potentially adjust its sign to ensure the rectangle does not cross the
            dateline.
            </summary>
            <param name="minX"></param>
            <param name="maxX"></param>
            <param name="minY"></param>
            <param name="maxY"></param>
            <returns></returns>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.MakeCircle(System.Double,System.Double,System.Double)">
            <summary>
            Construct a circle. The units of "distance" should be the same as x &amp; y.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.MakeCircle(Spatial4n.Core.Shapes.IPoint,System.Double)">
            <summary>
            Construct a circle. The units of "distance" should be the same as x &amp; y.
            </summary>
            <param name="point"></param>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.MakeLineString(System.Collections.Generic.IList{Spatial4n.Core.Shapes.IPoint})">
            <summary>
            Constructs a line string. It's an ordered sequence of connected vertexes. There
            is no official shape/interface for it yet so we just return <see cref="T:Spatial4n.Core.Shapes.IShape"/>.
            </summary>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.MakeBufferedLineString(System.Collections.Generic.IList{Spatial4n.Core.Shapes.IPoint},System.Double)">
            <summary>
            Constructs a buffered line string. It's an ordered sequence of connected vertexes,
            with a buffer distance along the line in all directions. There
            is no official shape/interface for it so we just return <see cref="T:Spatial4n.Core.Shapes.IShape"/>.
            </summary>
            <param name="points"></param>
            <param name="buf"></param>
            <returns></returns>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.MakeCollection(System.Collections.Generic.IList{Spatial4n.Core.Shapes.IShape})">
            <summary>
            Construct a <see cref="T:Spatial4n.Core.Shapes.ShapeCollection"/>, analogous to an OGC GeometryCollection.
            </summary>
            <param name="coll"></param>
            <returns></returns>
        </member>
        <member name="P:Spatial4n.Core.Context.SpatialContext.WktShapeParser">
            <summary>
            The <see cref="T:Spatial4n.Core.IO.WktShapeParser"/> used by <see cref="M:Spatial4n.Core.Context.SpatialContext.ReadShapeFromWkt(System.String)"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.ReadShapeFromWkt(System.String)">
            <summary>
            Reads a shape from the string formatted in WKT.
            See <see cref="T:Spatial4n.Core.IO.WktShapeParser"/>.
            </summary>
            <param name="wkt">non-null WKT.</param>
            <returns>non-null</returns>
            <exception cref="T:Spatial4n.Core.Exceptions.ParseException">if it failed to parse.</exception>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.ReadShape(System.String)">
            <summary>
            Reads the shape from a String using the old/deprecated
            <see cref="T:Spatial4n.Core.IO.LegacyShapeReadWriterFormat"/>.
            Instead you should use standard WKT via <see cref="M:Spatial4n.Core.Context.SpatialContext.ReadShapeFromWkt(System.String)"/>. This method falls
            back on WKT if it's not in the legacy format.
            </summary>
            <param name="value">non-null</param>
            <returns>non-null</returns>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContext.ToString(Spatial4n.Core.Shapes.IShape)">
            <summary>
            Writes the shape to a String using the old/deprecated
            <see cref="T:Spatial4n.Core.IO.LegacyShapeReadWriterFormat"/>. The NTS based subclass will write it
            to WKT if the legacy format doesn't support that shape.
            <para>
            Spatial4n in the near future won't support writing shapes to strings.
            </para>
            </summary>
            <param name="shape">non-null</param>
            <returns>non-null</returns>
        </member>
        <member name="T:Spatial4n.Core.Context.SpatialContextFactory">
            <summary>
            Factory for a <see cref="T:Spatial4n.Core.Context.SpatialContext"/> based on configuration data.  Call
            <see cref="M:Spatial4n.Core.Context.SpatialContextFactory.MakeSpatialContext(System.Collections.Generic.IDictionary{System.String,System.String})"/> to construct one via string name-value
            pairs. To construct one via code then create a factory instance, set the fields, then call
            <see cref="M:Spatial4n.Core.Context.SpatialContextFactory.NewSpatialContext"/>.
            </summary>
        </member>
        <member name="F:Spatial4n.Core.Context.SpatialContextFactory.args">
            <summary>
            Set by <see cref="M:Spatial4n.Core.Context.SpatialContextFactory.MakeSpatialContext(System.Collections.Generic.IDictionary{System.String,System.String})"/>.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContextFactory.MakeSpatialContext(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Creates a new <see cref="T:Spatial4n.Core.Context.SpatialContext"/> based on configuration in
            <paramref name="args"/>.  See the class definition for what keys are looked up
            in it.
            The factory class is looked up via "spatialContextFactory" in args
            then falling back to an <see cref="M:System.Environment.GetEnvironmentVariable(System.String)"/> setting (with initial caps). If neither are specified
            then <see cref="T:Spatial4n.Core.Context.SpatialContextFactory"/> is chosen.
            </summary>
            <param name="args">Non-null map of name-value pairs.</param>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContextFactory.InitField(System.String)">
            <summary>
            Gets <paramref name="name"/> from args and populates a field by the same name with the value.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Context.SpatialContextFactory.NewSpatialContext">
            <summary>
            Subclasses should simply construct the instance from the initialized configuration.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Distance.CartesianDistCalc">
            <summary>
            Calculates based on Euclidean / Cartesian 2d plane.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.CartesianDistCalc.#ctor(System.Boolean)">
            <summary>
            
            </summary>
            <param name="squared">
            Set to true to have <see cref="M:Spatial4n.Core.Distance.AbstractDistanceCalculator.Distance(Spatial4n.Core.Shapes.IPoint,Spatial4n.Core.Shapes.IPoint)"/>
            return the square of the correct answer. This is a
            performance optimization used when sorting in which the
            actual distance doesn't matter so long as the sort order is
            consistent.
            </param>
        </member>
        <member name="M:Spatial4n.Core.Distance.IDistanceCalculator.Distance(Spatial4n.Core.Shapes.IPoint,Spatial4n.Core.Shapes.IPoint)">
            <summary>
            The distance between <paramref name="from"/> and <paramref name="to"/>.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.IDistanceCalculator.Distance(Spatial4n.Core.Shapes.IPoint,System.Double,System.Double)">
            <summary>
            The distance between <paramref name="from"/> and <c>Point(toX,toY)</c>.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.IDistanceCalculator.Within(Spatial4n.Core.Shapes.IPoint,System.Double,System.Double,System.Double)">
            <summary>
            Returns true if the distance between from and to is &lt;= distance.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.IDistanceCalculator.PointOnBearing(Spatial4n.Core.Shapes.IPoint,System.Double,System.Double,Spatial4n.Core.Context.SpatialContext,Spatial4n.Core.Shapes.IPoint)">
            <summary>
            Calculates where a destination point is given an origin (<c>from</c>)
            distance, and bearing (given in degrees -- 0-360).  If reuse is given, then
            this method may <see cref="M:Spatial4n.Core.Shapes.IPoint.Reset(System.Double,System.Double)"/> it and return it.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.IDistanceCalculator.CalcBoxByDistFromPt(Spatial4n.Core.Shapes.IPoint,System.Double,Spatial4n.Core.Context.SpatialContext,Spatial4n.Core.Shapes.IRectangle)">
            <summary>
            Calculates the bounding box of a circle, as specified by its center point
            and distance.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.IDistanceCalculator.CalcBoxByDistFromPt_yHorizAxisDEG(Spatial4n.Core.Shapes.IPoint,System.Double,Spatial4n.Core.Context.SpatialContext)">
            <summary>
            The <c>Y</c> coordinate of the horizontal axis of a circle that has maximum width. On a
            2D plane, this result is always <c>from.Y</c> but, perhaps surprisingly, on a sphere
            it is going to be slightly different.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Distance.DistanceUtils">
            <summary>
            Various distance calculations and constants. To the extent possible, a 
            <see cref="T:Spatial4n.Core.Distance.IDistanceCalculator"/>, retrieved from <see cref="P:Spatial4n.Core.Context.SpatialContext.DistCalc"/>
            should be used in preference to calling these methods directly.
            <para>
            This code came from <a href="https://issues.apache.org/jira/browse/LUCENE-1387">Apache
            Lucene, LUCENE-1387</a>, which in turn came from "LocalLucene".
            </para>
            </summary>
        </member>
        <member name="F:Spatial4n.Core.Distance.DistanceUtils.EARTH_MEAN_RADIUS_KM">
             <summary>
             The International Union of Geodesy and Geophysics says the Earth's mean radius in KM is:
            
             [1] http://en.wikipedia.org/wiki/Earth_radius
             </summary>
        </member>
        <member name="F:Spatial4n.Core.Distance.DistanceUtils.DEG_TO_KM">
            <summary>
            Equivalent to Degrees2Dist(1, EARTH_MEAN_RADIUS_KM)
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.VectorDistance(System.Double[],System.Double[],System.Double)">
            <summary>
            Calculate the p-norm (i.e. length) between two vectors
            </summary>
            <param name="vec1">The first vector</param>
            <param name="vec2">The second vector</param>
            <param name="power">The power (2 for cartesian distance, 1 for manhattan, etc.)</param>
            <returns>The length. See http://en.wikipedia.org/wiki/Lp_space </returns>
            <seealso cref="M:Spatial4n.Core.Distance.DistanceUtils.VectorDistance(System.Double[],System.Double[],System.Double,System.Double)"/>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.VectorDistance(System.Double[],System.Double[],System.Double,System.Double)">
            <summary>
            Calculate the p-norm (i.e. length) between two vectors
            </summary>
            <param name="vec1">The first vector</param>
            <param name="vec2">The second vector</param>
            <param name="power">The power (2 for cartesian distance, 1 for manhattan, etc.)</param>
            <param name="oneOverPower">If you've precalculated <paramref name="oneOverPower"/> and cached it, 
            use this method to save one division operation over <seealso cref="M:Spatial4n.Core.Distance.DistanceUtils.VectorDistance(System.Double[],System.Double[],System.Double)"/>.</param>
            <returns>The length.</returns>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.VectorBoxCorner(System.Double[],System.Double[],System.Double,System.Boolean)">
            <summary>
            Return the coordinates of a vector that is the corner of a box (upper right or lower left), assuming a Rectangular
            coordinate system.  Note, this does not apply for points on a sphere or ellipse (although it could be used as an approximation).
            </summary>
            <param name="center">The center point</param>
            <param name="result">Holds the result, potentially resizing if needed.</param>
            <param name="distance">The distance from the center to the corner</param>
            <param name="upperRight">If true, return the coords for the upper right corner, else return the lower left.</param>
            <returns>The point, either the upperLeft or the lower right</returns>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.PointOnBearingRAD(System.Double,System.Double,System.Double,System.Double,Spatial4n.Core.Context.SpatialContext,Spatial4n.Core.Shapes.IPoint)">
            <summary>
            Given a start point (startLat, startLon) and a bearing on a sphere of radius <i>sphereRadius</i>, return the destination point.
            </summary>
            <param name="startLat">The starting point latitude, in radians</param>
            <param name="startLon">The starting point longitude, in radians</param>
            <param name="distanceRAD">The distance to travel along the bearing in radians.</param>
            <param name="bearingRAD">The bearing, in radians.  North is a 0, moving clockwise till radians(360).</param>
            <param name="ctx"></param>
            <param name="reuse">A preallocated object to hold the results.</param>
            <returns>The destination point, in radians.  First entry is latitude, second is longitude</returns>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.NormLonDEG(System.Double)">
            <summary>
            Puts in range -180 &lt;= lon_deg &lt;= +180.
            </summary>
            <param name="lon_deg"></param>
            <returns></returns>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.NormLatDEG(System.Double)">
            <summary>
            Puts in range -90 &lt;= lat_deg &lt;= 90.
            </summary>
            <param name="lat_deg"></param>
            <returns></returns>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.CalcBoxByDistFromPtDEG(System.Double,System.Double,System.Double,Spatial4n.Core.Context.SpatialContext,Spatial4n.Core.Shapes.IRectangle)">
            <summary>
            Calculates the bounding box of a circle, as specified by its center point
            and distance. <paramref name="reuse"/> is an optional argument to store the
            results to avoid object creation.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.CalcBoxByDistFromPt_deltaLonDEG(System.Double,System.Double,System.Double)">
            <summary>
            The delta longitude of a point-distance. In other words, half the width of
            the bounding box of a circle.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.CalcBoxByDistFromPt_latHorizAxisDEG(System.Double,System.Double,System.Double)">
            <summary>
            The latitude of the horizontal axis (e.g. left-right line)
            of a circle.  The horizontal axis of a circle passes through its furthest
            left-most and right-most edges. On a 2D plane, this result is always
            <c>from.Y</c> but, perhaps surprisingly, on a sphere it is going
            to be slightly different.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.CalcLonDegreesAtLat(System.Double,System.Double)">
            <summary>
            Calculates the degrees longitude distance at latitude <paramref name="lat"/> to cover
            a distance <paramref name="dist"/>.
            <para>
            Used to calculate a new expanded buffer distance to account for skewing
            effects for shapes that use the lat-lon space as a 2D plane instead of a
            sphere. The expanded buffer will be sure to cover the intended area, but
            the shape is still skewed and so it will cover a larger area. For latitude
            0 (the equator) the result is the same buffer. At 60 (or -60) degrees, the
            result is twice the buffer, meaning that a shape at 60 degrees is twice as
            high as it is wide when projected onto a lat-lon plane even if in the real
            world it's equal all around.
            </para>
            If the result added to abs(<paramref name="lat"/>) is &gt;= 90 degrees, then skewing is
            so severe that the caller should consider tossing the shape and
            substituting a spherical cap instead.
            </summary>
            <param name="lat">latitude in degrees</param>
            <param name="dist">distance in degrees</param>
            <returns>longitudinal degrees (x delta) at input latitude that is &gt;= 
            <paramref name="dist"/> distance. Will be &gt;= dist and &lt;= 90.</returns>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.DistSquaredCartesian(System.Double[],System.Double[])">
            <summary>
            The square of the cartesian Distance.  Not really a distance, but useful if all that matters is
            comparing the result to another one.
            </summary>
            <param name="vec1">The first point</param>
            <param name="vec2">The second point</param>
            <returns>The squared cartesian distance</returns>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.DistHaversineRAD(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="lat1">The y coordinate of the first point, in radians</param>
            <param name="lon1">The x coordinate of the first point, in radians</param>
            <param name="lat2">The y coordinate of the second point, in radians</param>
            <param name="lon2">The x coordinate of the second point, in radians</param>
            <returns>The distance between the two points, as determined by the Haversine formula, in radians.</returns>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.DistLawOfCosinesRAD(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculates the distance between two lat/lng's using the Law of Cosines. Due to numeric conditioning
            errors, it is not as accurate as the Haversine formula for small distances.  But with
            double precision, it isn't that bad -- <a href="http://www.movable-type.co.uk/scripts/latlong.html">
            allegedly 1 meter</a>.
            <para>
            See <a href="http://gis.stackexchange.com/questions/4906/why-is-law-of-cosines-more-preferable-than-haversine-when-calculating-distance-b">
            Why is law of cosines more preferable than haversine when calculating distance between two latitude-longitude points?</a>
            </para>
            The arguments and return value are in radians.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.DistVincentyRAD(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculates the great circle distance using the Vincenty Formula, simplified for a spherical model. This formula
            is accurate for any pair of points. The equation
            was taken from <a href="http://en.wikipedia.org/wiki/Great-circle_distance">Wikipedia</a>.
            <para>
            The arguments are in radians, and the result is in radians.
            </para>
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.Dist2Degrees(System.Double,System.Double)">
            <summary>
            Converts a distance in the units of the radius to degrees (360 degrees are
            in a circle). A spherical earth model is assumed.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.Degrees2Dist(System.Double,System.Double)">
            <summary>
            Converts <paramref name="degrees"/> (1/360th of circumference of a circle) into a
            distance as measured by the units of the radius.  A spherical earth model
            is assumed.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.Dist2Radians(System.Double,System.Double)">
            <summary>
            Converts a distance in the units of <paramref name="radius"/> (e.g. kilometers)
            to radians (multiples of the radius). A spherical earth model is assumed.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.Radians2Dist(System.Double,System.Double)">
            <summary>
            Converts <paramref name="radians"/> (multiples of the <paramref name="radius"/>) to
            distance in the units of the radius (e.g. kilometers).
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.ToRadians(System.Double)">
            <summary>
            Same as Java's <c>Math.toRadians(double)</c> but 3x faster (multiply vs. divide).
            See CompareRadiansSnippet.java in tests.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Distance.DistanceUtils.ToDegrees(System.Double)">
            <summary>
            Same as Java's <c>Math.toDegrees(double)</c> but 3x faster (multiply vs. divide).
            See CompareRadiansSnippet.java in tests.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Distance.GeodesicSphereDistCalc">
            <summary>
            A base class for a Distance Calculator that assumes a spherical earth model. 
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Exceptions.InvalidShapeException">
            <summary>
            A shape was constructed but failed because, based on the given parts, it's invalid. For example
            a rectangle's minimum Y was specified as greater than the maximum Y. This class is not used for
            parsing exceptions; that's usually <see cref="T:Spatial4n.Core.Exceptions.ParseException"/>.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Exceptions.ParseException">
            <summary>
            Spatial4n specific type used to throw/catch a parsing error including the offset.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Exceptions.RuntimeException">
            <summary>
            Spatial4n specific class - used to mimic Java's RuntimeException because we sometimes need to catch
            exceptions that are lower level than InvalidShapeException, but need something more specialized than
            <see cref="T:System.Exception"/>.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.IO.BinaryCodec">
            <summary>
            A binary shape format. It is <c>not</c> designed to be a published standard, unlike Well Known
            Binary (WKB). The initial release is simple but it could get more optimized to use fewer bytes or
            to write &amp; read pre-computed index structures.
            <para>
            Immutable and thread-safe.
            </para>
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.BinaryCodec.WriteShapeByTypeIfSupported(System.IO.BinaryWriter,Spatial4n.Core.Shapes.IShape)">
            <summary>
            Note: writes the type byte even if not supported
            </summary>
        </member>
        <member name="T:Spatial4n.Core.IO.LegacyShapeReadWriterFormat">
            <summary>
            Reads &amp; writes a shape from a given string in the old format.
            <list type="bullet">
                <item>
                Point: X Y<para/>
                1.23 4.56
                </item>
                <item>
                Rect: XMin YMin XMax YMax<para/>
                1.23 4.56 7.87 4.56
                </item>
                <item>
                {CIRCLE} '(' {POINT} {DISTANCE} ')'<para/>
                CIRCLE is "CIRCLE" or "Circle" (no other case), and POINT is "X Y" order pair of doubles, or
                "Y,X" (lat,lon) pair of doubles, and DISTANCE is "d=RADIUS" or "distance=RADIUS" where RADIUS
                is a double that is the distance radius in degrees.
                </item>
            </list>
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.LegacyShapeReadWriterFormat.WriteShape(Spatial4n.Core.Shapes.IShape)">
            <summary>
            Writes a shape to a string, in a format that can be read by
            <see cref="T:Spatial4n.Core.Context.SpatialContext"/>.
            </summary>
            <param name="shape">Not null</param>
            <returns>Not null</returns>
        </member>
        <member name="M:Spatial4n.Core.IO.LegacyShapeReadWriterFormat.WriteShape(Spatial4n.Core.Shapes.IShape,System.String)">
            <summary>
            Writes a shape to a string, in a format that can be read by
            <see cref="T:Spatial4n.Core.Context.SpatialContext"/>.
            Overloaded to provide a <paramref name="numberFormat"/>.
            </summary>
            <param name="shape">Not null</param>
            <param name="numberFormat">A standard or custom numeric .NET format string (float).</param>
            <returns>Not null</returns>
        </member>
        <member name="M:Spatial4n.Core.IO.LegacyShapeReadWriterFormat.ReadShapeOrNull(System.String,Spatial4n.Core.Context.SpatialContext)">
            <summary>
            Reads the shape specification as defined in the class javadocs. If the first character is
            a letter but it doesn't complete out "Circle" or "CIRCLE" then this method returns null,
            offering the caller the opportunity to potentially try additional parsing.
            If the first character is not a letter then it's assumed to be a point or rectangle. If that
            doesn't work out then an <see cref="T:Spatial4n.Core.Exceptions.InvalidShapeException"/> is thrown.
            </summary>
            <param name="str"></param>
            <param name="ctx"></param>
            <returns></returns>
        </member>
        <member name="M:Spatial4n.Core.IO.LegacyShapeReadWriterFormat.ReadLatCommaLonPoint(System.String,Spatial4n.Core.Context.SpatialContext)">
            <summary>
            Reads geospatial latitude then a comma then longitude.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.IO.ParseUtils">
            <summary>
            Utility methods related to parsing a series of numbers.
            <para>
            This code came from <see cref="T:Spatial4n.Core.Distance.DistanceUtils"/>, which came from
            <a href="https://issues.apache.org/jira/browse/LUCENE-773">Apache
            Lucene, LUCENE-773</a>, which in turn came from "LocalLucene".
            </para>
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.ParseUtils.ParsePoint(System.String[],System.String,System.Int32)">
            <summary>
            Given a string containing <c>dimension</c> values encoded in it, separated by commas, return a string array of length <c>dimension</c>
            containing the values.
            </summary>
            <param name="_out">A preallocated array.  Must be size dimension.  If it is not it will be resized.</param>
            <param name="externalVal">The value to parse</param>
            <param name="dimension">The expected number of values for the point</param>
            <returns>An array of the values that make up the point (aka vector)</returns>
            <exception cref="T:Spatial4n.Core.Exceptions.InvalidShapeException">If the dimension specified does not match the number of values in the <paramref name="externalVal"/>.</exception>
        </member>
        <member name="M:Spatial4n.Core.IO.ParseUtils.ParsePointDouble(System.Double[],System.String,System.Int32)">
            <summary>
            Given a string containing <c>dimension</c> values encoded in it, separated by commas, return a double array of length <c>dimension</c>
            containing the values.
            </summary>
            <param name="out">A preallocated array.  Must be size dimension.  If it is not it will be resized.</param>
            <param name="externalVal">The value to parse</param>
            <param name="dimension">The expected number of values for the point</param>
            <returns>An array of the values that make up the point (aka vector)</returns>
            <exception cref="T:Spatial4n.Core.Exceptions.InvalidShapeException">If the dimension specified does not match the number of values in the <paramref name="externalVal"/>.</exception>
        </member>
        <member name="M:Spatial4n.Core.IO.ParseUtils.ParseLatitudeLongitude(System.String)">
            <summary>
            Extract (by calling <see cref="M:Spatial4n.Core.IO.ParseUtils.ParsePoint(System.String[],System.String,System.Int32)"/> and validate the latitude and longitude contained
            in the string by making sure the latitude is between 90 &amp; -90 and longitude is between -180 and 180.<p/>
            The latitude is assumed to be the first part of the string and the longitude the second part.
            </summary>
            <param name="latLonStr">The string to parse.  Latitude is the first value, longitude is the second.</param>
            <returns>The lat long</returns>
            <exception cref="T:Spatial4n.Core.Exceptions.InvalidShapeException">if there was an error parsing</exception>
        </member>
        <member name="M:Spatial4n.Core.IO.ParseUtils.ParseLatitudeLongitude(System.Double[],System.String)">
            <summary>
            A variation of <see cref="M:Spatial4n.Core.IO.ParseUtils.ParseLatitudeLongitude(System.String)"/> that re-uses an output array.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.IO.WktShapeParser">
            <summary>
            An extensible parser for <a href="http://en.wikipedia.org/wiki/Well-known_text">
            Well Known Text (WKT)</a>.
            The shapes supported by this class are:
            <list type="bullet">
                <item>POINT</item>
                <item>MULTIPOINT</item>
                <item>ENVELOPE (strictly isn't WKT but is defined by OGC's <a href="http://docs.geoserver.org/stable/en/user/tutorials/cql/cql_tutorial.html"> Common Query Language(CQL)</a>)</item>
                <item>LINESTRING</item>
                <item>MULTILINESTRING</item>
                <item>GEOMETRYCOLLECTION</item>
                <item>BUFFER (non-standard Spatial4n operation)</item>
            </list>
            'EMPTY' is supported. Specifying 'Z', 'M', or any other dimensionality in the WKT is effectively
            ignored.  Thus, you can specify any number of numbers in the coordinate points but only the first
            two take effect.  The docs for the <c>parse___Shape</c> methods further describe these
            shapes, or you
            <para>
            Most users of this class will call just one method: <see cref="M:Spatial4n.Core.IO.WktShapeParser.Parse(System.String)"/>, or
            <see cref="M:Spatial4n.Core.IO.WktShapeParser.ParseIfSupported(System.String)"/> to not fail if it isn't parse-able.
            </para>
            <para>
            To support more shapes, extend this class and override
            <see cref="M:Spatial4n.Core.IO.WktShapeParser.ParseShapeByType(Spatial4n.Core.IO.WktShapeParser.State,System.String)"/>. It's also possible to delegate to
            a WKTParser by also delegating <see cref="M:Spatial4n.Core.IO.WktShapeParser.NewState(System.String)"/>.
            </para>
            <para>
            Note, instances of this base class are threadsafe.
            </para>
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.#ctor(Spatial4n.Core.Context.SpatialContext,Spatial4n.Core.Context.SpatialContextFactory)">
            <summary>
            This constructor is required by <see cref="M:Spatial4n.Core.Context.SpatialContextFactory.MakeWktShapeParser(Spatial4n.Core.Context.SpatialContext)"/>.
            </summary>
            <param name="ctx"></param>
            <param name="factory"></param>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.Parse(System.String)">
            <summary>
            Parses the wktString, returning the defined <see cref="T:Spatial4n.Core.Shapes.IShape"/>.
            </summary>
            <param name="wktString"></param>
            <returns>Non-null <see cref="T:Spatial4n.Core.Shapes.IShape"/> defined in the string</returns>
            <exception cref="T:Spatial4n.Core.Exceptions.ParseException">Thrown if there is an error in the <see cref="T:Spatial4n.Core.Shapes.IShape"/> definition</exception>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.ParseIfSupported(System.String)">
            <summary>
            Parses the wktString, returning the defined <see cref="T:Spatial4n.Core.Shapes.IShape"/>. If it can't because the
            shape name is unknown or an empty or blank string was passed, then it returns null.
            If the WKT starts with a supported shape but contains an inner unsupported shape then
            it will result in a <see cref="T:Spatial4n.Core.Exceptions.ParseException"/>.
            </summary>
            <param name="wktString">non-null, can be empty or have surrounding whitespace</param>
            <returns><see cref="T:Spatial4n.Core.Shapes.IShape"/>, null if unknown / unsupported shape.</returns>
            <exception cref="T:Spatial4n.Core.Exceptions.ParseException">Thrown if there is an error in the <see cref="T:Spatial4n.Core.Shapes.IShape"/> definition</exception>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.NewState(System.String)">
            <summary>
            (internal) Creates a new State with the given String. It's only called by
            <see cref="M:Spatial4n.Core.IO.WktShapeParser.ParseIfSupported(System.String)"/>. This is an extension point for subclassing.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.ParseShapeByType(Spatial4n.Core.IO.WktShapeParser.State,System.String)">
            <summary>
            (internal) Parses the remainder of a shape definition following the shape's name
            given as <paramref name="shapeType"/> already consumed via
            <see cref="M:Spatial4n.Core.IO.WktShapeParser.State.NextWord"/>. If
            it's able to parse the shape, <see cref="F:Spatial4n.Core.IO.WktShapeParser.State.offset"/> 
            should be advanced beyond
            it (e.g. to the ',' or ')' or EOF in general). The default implementation
            checks the name against some predefined names and calls corresponding
            parse methods to handle the rest. Overriding this method is an
            excellent extension point for additional shape types. Or, use this class by delegation to this
            method.
            <para>
            When writing a parse method that reacts to a specific shape type, remember to handle the
            dimension and EMPTY token via <see cref="M:Spatial4n.Core.IO.WktShapeParser.State.NextIfEmptyAndSkipZM"/>.
            </para>
            </summary>
            <param name="state"></param>
            <param name="shapeType">Non-Null string; could have mixed case. The first character is a letter.</param>
            <returns>The shape or null if not supported / unknown.</returns>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.ParseBufferShape(Spatial4n.Core.IO.WktShapeParser.State)">
            <summary>
            Parses the BUFFER operation applied to a parsed shape.
            <code>
              '(' shape ',' number ')'
            </code>
            Whereas 'number' is the distance to buffer the shape by.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.NormDist(System.Double)">
            <summary>
            Called to normalize a value that isn't X or Y. X &amp; Y or normalized via
            <see cref="M:Spatial4n.Core.Context.SpatialContext.NormX(System.Double)"/> &amp; <see cref="M:Spatial4n.Core.Context.SpatialContext.NormY(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.ParsePointShape(Spatial4n.Core.IO.WktShapeParser.State)">
            <summary>
            Parses a POINT shape from the raw string.
            <code>
              '(' coordinate ')'
            </code>
            </summary>
            <seealso cref="M:Spatial4n.Core.IO.WktShapeParser.Point(Spatial4n.Core.IO.WktShapeParser.State)"/>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.ParseMultiPointShape(Spatial4n.Core.IO.WktShapeParser.State)">
            <summary>
            Parses a MULTIPOINT shape from the raw string -- a collection of points.
            <code>
              '(' coordinate (',' coordinate )* ')'
            </code>
            Furthermore, coordinate can optionally be wrapped in parenthesis.
            </summary>
            <seealso cref="M:Spatial4n.Core.IO.WktShapeParser.Point(Spatial4n.Core.IO.WktShapeParser.State)"/>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.ParseEnvelopeShape(Spatial4n.Core.IO.WktShapeParser.State)">
            <summary>
            Parses an ENVELOPE (aka Rectangle) shape from the raw string. The values are normalized.
            <para>
            Source: OGC "Catalogue Services Specification", the "CQL" (Common Query Language) sub-spec.
            <c>Note the inconsistent order of the min &amp; max values between x &amp; y!</c>
            <code>
              '(' x1 ',' x2 ',' y2 ',' y1 ')'
            </code>
            </para>
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.ParseLineStringShape(Spatial4n.Core.IO.WktShapeParser.State)">
            <summary>
            Parses a LINESTRING shape from the raw string -- an ordered sequence of points.
            <code>
              coordinateSequence
            </code>
            </summary>
            <seealso cref="M:Spatial4n.Core.IO.WktShapeParser.PointList(Spatial4n.Core.IO.WktShapeParser.State)"/>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.ParseMultiLineStringShape(Spatial4n.Core.IO.WktShapeParser.State)">
            <summary>
            Parses a MULTILINESTRING shape from the raw string -- a collection of line strings.
            <code>
              '(' coordinateSequence (',' coordinateSequence )* ')'
            </code>
            </summary>
            <seealso cref="M:Spatial4n.Core.IO.WktShapeParser.ParseLineStringShape(Spatial4n.Core.IO.WktShapeParser.State)"/>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.ParseGeometryCollectionShape(Spatial4n.Core.IO.WktShapeParser.State)">
            <summary>
            Parses a GEOMETRYCOLLECTION shape from the raw string.
            <code>
              '(' shape (',' shape )* ')'
            </code>
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.Shape(Spatial4n.Core.IO.WktShapeParser.State)">
            <summary>
            Reads a shape from the current position, starting with the name of the shape. It
            calls <seealso cref="M:Spatial4n.Core.IO.WktShapeParser.ParseShapeByType(Spatial4n.Core.IO.WktShapeParser.State,System.String)"/>
            and throws an exception if the shape wasn't supported.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.PointList(Spatial4n.Core.IO.WktShapeParser.State)">
            <summary>
            Reads a list of Points (AKA CoordinateSequence) from the current position.
            <code>
              '(' coordinate (',' coordinate )* ')'
            </code>
            </summary>
            <seealso cref="M:Spatial4n.Core.IO.WktShapeParser.Point(Spatial4n.Core.IO.WktShapeParser.State)"/>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.Point(Spatial4n.Core.IO.WktShapeParser.State)">
            <summary>
            Reads a raw Point (AKA Coordinate) from the current position. Only the first 2 numbers are
            used.  The values are normalized.
            <code>
              number number number*
            </code>
            </summary>
        </member>
        <member name="T:Spatial4n.Core.IO.WktShapeParser.State">
            <summary>
            The parse state.
            </summary>
        </member>
        <member name="F:Spatial4n.Core.IO.WktShapeParser.State.rawString">
            <summary>Set in <see cref="M:Spatial4n.Core.IO.WktShapeParser.ParseIfSupported(System.String)"/>.</summary>
        </member>
        <member name="F:Spatial4n.Core.IO.WktShapeParser.State.offset">
            <summary>Offset of the next char in <see cref="F:Spatial4n.Core.IO.WktShapeParser.State.rawString"/> to be read. </summary>
        </member>
        <member name="F:Spatial4n.Core.IO.WktShapeParser.State.dimension">
            <summary>Dimensionality specifier (e.g. 'Z', or 'M') following a shape type name.</summary>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.State.NextWord">
            <summary>
            Reads the word starting at the current character position. The word
            terminates once <see cref="M:Spatial4n.Core.IO.WktShapeParser.State.IsIdentifierPartCharacter(System.Char)"/> (which is identical to Java's <c>Character.isJavaIdentifierPart(char)</c>) returns false (or EOF).
            <see cref="F:Spatial4n.Core.IO.WktShapeParser.State.offset"/> is advanced past whitespace.
            </summary>
            <returns>Non-null non-empty string.</returns>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.State.NextIfEmptyAndSkipZM">
            <summary>
            Skips over a dimensionality token (e.g. 'Z' or 'M') if found, storing in
            <see cref="F:Spatial4n.Core.IO.WktShapeParser.State.dimension"/>, and then looks for EMPTY, consuming that and whitespace.
            <code>
              dimensionToken? 'EMPTY'?
            </code>
            </summary>
            <returns>True if EMPTY was found.</returns>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.State.NextDouble">
            <summary>
            Reads in a double from the string. Parses digits with an optional decimal, sign, or exponent.
            NaN and Infinity are not supported.
            <see cref="F:Spatial4n.Core.IO.WktShapeParser.State.offset"/> is advanced past whitespace.
            </summary>
            <returns><see cref="T:System.Double"/> value</returns>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.State.SkipDouble">
            <summary>
            Advances offset forward until it points to a character that isn't part of a number.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.State.SkipNextDoubles">
            <summary>
            Advances past as many doubles as there are, with intervening whitespace.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.State.NextExpect(System.Char)">
            <summary>
            Verifies that the current character is of the expected value.
            If the character is the expected value, then it is consumed and
            <see cref="F:Spatial4n.Core.IO.WktShapeParser.State.offset"/> is advanced past whitespace.
            </summary>
            <param name="expected">The expected char.</param>
        </member>
        <member name="P:Spatial4n.Core.IO.WktShapeParser.State.Eof">
            <summary>
            If the string is consumed, i.e. at end-of-file.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.State.NextIf(System.Char)">
            <summary>
            If the current character is <paramref name="expected"/>, then offset is advanced after it and any
            subsequent whitespace. Otherwise, false is returned.
            </summary>
            <param name="expected">The expected char</param>
            <returns>true if consumed</returns>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.State.NextIfWhitespace">
            <summary>
            Moves offset to next non-whitespace character. Doesn't move if the offset is already at
            non-whitespace. <c>There is very little reason for subclasses to call this because
            most other parsing methods call it.</c>
            </summary>
        </member>
        <member name="M:Spatial4n.Core.IO.WktShapeParser.State.NextSubShapeString">
            <summary>
            Returns the next chunk of text till the next ',' or ')' (non-inclusive)
            or EOF. If a '(' is encountered, then it looks past its matching ')',
            taking care to handle nested matching parenthesis too. It's designed to be
            of use to subclasses that wish to get the entire subshape at the current
            position as a string so that it might be passed to other software that
            will parse it.
            <para>
            Example:
            <code>
              OUTER(INNER(3, 5))
            </code>
            If this is called when offset is at the first character, then it will
            return this whole string.  If called at the "I" then it will return
            "INNER(3, 5)".  If called at "3", then it will return "3".  In all cases,
            offset will be positioned at the next position following the returned
            substring.
            </para>
            </summary>
            <returns>non-null substring.</returns>
        </member>
        <member name="T:Spatial4n.Core.Shapes.ICircle">
            <summary>
            A circle, also known as a point-radius since that is what it is comprised of.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.ICircle.Reset(System.Double,System.Double,System.Double)">
            <summary>
            Expert: Resets the state of this shape given the arguments. This is a
            performance feature to avoid excessive <see cref="T:Spatial4n.Core.Shapes.IShape"/> object allocation as well as
            some argument error checking. Mutable shapes is error-prone so use with
            care.
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.ICircle.Radius">
            <summary>
            The distance from the point's center to its edge, measured in the same
            units as x &amp; y (e.g. degrees if WGS84).
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Shapes.Impl.BufferedLine">
            <summary>
            INTERNAL: A line between two points with a buffer distance extending in every direction. By
            contrast, an un-buffered line covers no area and as such is extremely unlikely to intersect with
            a point. <see cref="T:Spatial4n.Core.Shapes.Impl.BufferedLine"/> isn't yet aware of geodesics (e.g. the dateline); it operates in Euclidean
            space.
            </summary>
        </member>
        <member name="F:Spatial4n.Core.Shapes.Impl.BufferedLine.linePrimary">
            <summary>the primary line; passes through pA &amp; pB</summary>
        </member>
        <member name="F:Spatial4n.Core.Shapes.Impl.BufferedLine.linePerp">
            <summary>perpendicular to the primary line, centered between pA &amp; pB</summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.BufferedLine.#ctor(Spatial4n.Core.Shapes.IPoint,Spatial4n.Core.Shapes.IPoint,System.Double,Spatial4n.Core.Context.SpatialContext)">
            <summary>
            Creates a buffered line from pA to pB. The buffer extends on both sides of
            the line, making the width 2x the buffer. The buffer extends out from
            pA &amp; pB, making the line in effect 2x the buffer longer than pA to pB.
            </summary>
            <param name="pA">start point</param>
            <param name="pB">end point</param>
            <param name="buf">the buffer distance in degrees</param>
            <param name="ctx"></param>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.BufferedLine.ExpandBufForLongitudeSkew(Spatial4n.Core.Shapes.IPoint,Spatial4n.Core.Shapes.IPoint,System.Double)">
            <summary>
            Calls <see cref="M:Spatial4n.Core.Distance.DistanceUtils.CalcLonDegreesAtLat(System.Double,System.Double)"/> given pA or pB's latitude;
            whichever is farthest. It's useful to expand a buffer of a line segment when used in
            a geospatial context to cover the desired area.
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.Impl.BufferedLine.LinePrimary">
            <summary>
            INTERNAL
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.Impl.BufferedLine.LinePerp">
            <summary>
            INTERNAL
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Shapes.Impl.BufferedLineString">
            <summary>
            A <see cref="T:Spatial4n.Core.Shapes.Impl.BufferedLineString"/> is a collection of <see cref="T:Spatial4n.Core.Shapes.Impl.BufferedLine"/> shapes,
            resulting in what some call a "Track" or "Polyline" (ESRI terminology).
            The buffer can be 0.  Note that <see cref="T:Spatial4n.Core.Shapes.Impl.BufferedLine"/> isn't yet aware of geodesics (e.g. the dateline).
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.BufferedLineString.#ctor(System.Collections.Generic.IList{Spatial4n.Core.Shapes.IPoint},System.Double,Spatial4n.Core.Context.SpatialContext)">
            <summary>
            Needs at least 1 point, usually more than that.  If just one then it's
            internally treated like 2 points.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.BufferedLineString.#ctor(System.Collections.Generic.IList{Spatial4n.Core.Shapes.IPoint},System.Double,System.Boolean,Spatial4n.Core.Context.SpatialContext)">
            <summary>
            
            </summary>
            <param name="points">ordered control points. If empty then this shape is empty.</param>
            <param name="buf">Buffer &gt;= 0</param>
            <param name="expandBufForLongitudeSkew">
            See <see cref="M:Spatial4n.Core.Shapes.Impl.BufferedLine.ExpandBufForLongitudeSkew(Spatial4n.Core.Shapes.IPoint,Spatial4n.Core.Shapes.IPoint,System.Double)"/>
            If true then the buffer for each segment is computed.
            </param>
            <param name="ctx"></param>
        </member>
        <member name="T:Spatial4n.Core.Shapes.Impl.Circle">
            <summary>
            A circle, also known as a point-radius, based on a
            <see cref="T:Spatial4n.Core.Distance.IDistanceCalculator"/> which does all the work. This implementation
            implementation should work for both cartesian 2D and geodetic sphere 
            surfaces.
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.Impl.Circle.BoundingBox">
            <summary>
            Note that the bounding box might contain a minX that is &gt; maxX, due to WGS84 dateline.
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.Impl.Circle.YAxis">
            <summary>
            The <c>Y</c> coordinate of where the circle axis intersect.
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.Impl.Circle.XAxis">
            <summary>
            The <c>X</c> coordinate of where the circle axis intersect.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.Circle.Equals(Spatial4n.Core.Shapes.ICircle,System.Object)">
            <summary>
            All <see cref="T:Spatial4n.Core.Shapes.ICircle"/> implementations should use this definition of <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.Circle.GetHashCode(Spatial4n.Core.Shapes.ICircle)">
            <summary>
            All <see cref="T:Spatial4n.Core.Shapes.ICircle"/> implementations should use this definition of <see cref="M:System.Object.GetHashCode"/>.
            </summary>
            <param name="thiz"></param>
            <returns></returns>
        </member>
        <member name="T:Spatial4n.Core.Shapes.Impl.GeoCircle">
            <summary>
            A circle as it exists on the surface of a sphere.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.GeoCircle.RelateRectanglePhase2(Spatial4n.Core.Shapes.IRectangle,Spatial4n.Core.Shapes.SpatialRelation)">
            <summary>
            Called after bounding box is intersected.
            </summary>
            <param name="r"></param>
            <param name="bboxSect"><see cref="F:Spatial4n.Core.Shapes.SpatialRelation.INTERSECTS"/> or <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.CONTAINS"/> from enclosingBox's intersection</param>
            <returns><see cref="F:Spatial4n.Core.Shapes.SpatialRelation.DISJOINT"/>, <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.CONTAINS"/>, or 
            <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.INTERSECTS"/> (not <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.WITHIN"/>)</returns>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.GeoCircle.NumCornersIntersect(Spatial4n.Core.Shapes.IRectangle)">
            <summary>
            Returns either 0 for none, 1 for some, or 4 for all.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Shapes.Impl.InfBufLine">
            <summary>
            INERNAL: A buffered line of infinite length.
            Public for test access.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.InfBufLine.DistanceUnbuffered(Spatial4n.Core.Shapes.IPoint)">
            <summary>
            INTERNAL AKA lineToPointDistance
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.InfBufLine.Quadrant(Spatial4n.Core.Shapes.IPoint)">
            <summary>
            INTERNAL: AKA lineToPointQuadrant
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.Impl.InfBufLine.DistDenomInv">
            <summary>
            <c>1 / Math.Sqrt(slope * slope + 1)</c>
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Shapes.Impl.Point">
            <summary>
            A basic 2D implementation of a Point.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.Point.#ctor(System.Double,System.Double,Spatial4n.Core.Context.SpatialContext)">
            <summary>
            A simple constructor without normalization / validation.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.Point.Equals(Spatial4n.Core.Shapes.IPoint,System.Object)">
            <summary>
            All <see cref="T:Spatial4n.Core.Shapes.IPoint"/> implementations should use this definition of <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.Point.GetHashCode(Spatial4n.Core.Shapes.IPoint)">
            <summary>
            All <see cref="T:Spatial4n.Core.Shapes.IPoint"/> implementations should use this definition of <see cref="M:System.Object.GetHashCode"/>.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Shapes.Impl.Range">
            <summary>
            INTERNAL: A numeric range between a pair of numbers.
            Perhaps this class could become 1st class citizen extending Shape but not now.
            Only public so is accessible from tests in another package.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.Range.LongitudeRange.Diff(System.Double,System.Double)">
            <summary>
            <c>a - b (compareTo order).  &lt; 0 if a &lt; b</c>
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Shapes.Impl.Rectangle">
            <summary>
            A simple Rectangle implementation that also supports a longitudinal
            wrap-around. When minX > maxX, this will assume it is world coordinates that
            cross the date line using degrees. Immutable &amp; threadsafe.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.Rectangle.#ctor(System.Double,System.Double,System.Double,System.Double,Spatial4n.Core.Context.SpatialContext)">
            <summary>
            A simple constructor without normalization / validation.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.Rectangle.#ctor(Spatial4n.Core.Shapes.IPoint,Spatial4n.Core.Shapes.IPoint,Spatial4n.Core.Context.SpatialContext)">
            <summary>
            A convenience constructor which pulls out the coordinates.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.Rectangle.#ctor(Spatial4n.Core.Shapes.IRectangle,Spatial4n.Core.Context.SpatialContext)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.Rectangle.Equals(Spatial4n.Core.Shapes.IRectangle,System.Object)">
            <summary>
            All <see cref="T:Spatial4n.Core.Shapes.IRectangle"/> implementations should use this definition of <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.Impl.Rectangle.GetHashCode(Spatial4n.Core.Shapes.IRectangle)">
            <summary>
            All <see cref="T:Spatial4n.Core.Shapes.IRectangle"/> implementations should use this definition of <see cref="M:System.Object.GetHashCode"/>.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Shapes.IPoint">
            <summary>
            A Point with X &amp; Y coordinates.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.IPoint.Reset(System.Double,System.Double)">
            <summary>
            Expert: Resets the state of this point given the arguments. This is a performance
            feature to avoid excessive <see cref="T:Spatial4n.Core.Shapes.IShape"/> object allocation as well as some
            argument normalization &amp; error checking. Mutable shapes is error-prone so use with
            care.
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.IPoint.X">
            <summary>
            The X coordinate, or Longitude in geospatial contexts.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Spatial4n.Core.Shapes.IPoint.Y">
            <summary>
            The Y coordinate, or Latitude in geospatial contexts.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Spatial4n.Core.Shapes.IRectangle">
            <summary>
            A rectangle aligned with the axis (i.e. it is not at an angle).
            <para>
            In geospatial contexts, it may cross the international date line (-180
            longitude) if <see cref="P:Spatial4n.Core.Shapes.IRectangle.CrossesDateLine"/> however it cannot pass the poles
            although it may span the globe.  It spans the globe if the X coordinate
            (Longitude) goes from -180 to 180 as seen from <see cref="P:Spatial4n.Core.Shapes.IRectangle.MinX"/> and <see cref="P:Spatial4n.Core.Shapes.IRectangle.MaxX"/>.
            </para>
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.IRectangle.Reset(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Expert: Resets the state of this shape given the arguments. This is a
            performance feature to avoid excessive Shape object allocation as well as
            some argument error checking. Mutable shapes is error-prone so use with
            care.
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.IRectangle.Width">
            <summary>
            The width. In geospatial contexts, this is generally in degrees longitude
            and is aware of the international dateline.  It will always be >= 0.
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.IRectangle.Height">
            <summary>
            The height. In geospatial contexts, this is in degrees latitude. It will
            always be >= 0.
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.IRectangle.MinX">
            <summary>The left edge of the X coordinate.</summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.IRectangle.MinY">
            <summary>The bottom edge of the Y coordinate.</summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.IRectangle.MaxX">
            <summary>The right edge of the X coordinate.</summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.IRectangle.MaxY">
            <summary>The top edge of the Y coordinate.</summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.IRectangle.CrossesDateLine">
            <summary>
            Only meaningful for geospatial contexts.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.IRectangle.RelateYRange(System.Double,System.Double)">
            <summary>
            A specialization of <see cref="M:Spatial4n.Core.Shapes.IShape.Relate(Spatial4n.Core.Shapes.IShape)"/>
            for a vertical line.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.IRectangle.RelateXRange(System.Double,System.Double)">
            <summary>
            A specialization of <see cref="M:Spatial4n.Core.Shapes.IShape.Relate(Spatial4n.Core.Shapes.IShape)"/>
            for a horizontal line.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Shapes.IShape">
            <summary>
            The base interface defining a geometric shape. Shape instances should be
            instantiated via one of the create* methods on a <see cref="T:Spatial4n.Core.Context.SpatialContext"/> or
            by reading WKT which calls those methods; they should <c>not</c> be
            created directly.
            <para>
            Shapes are generally immutable and thread-safe. If a particular shape has a
            <c>Reset(...)</c> method then its use means the shape is actually
            mutable. Mutating shape state is considered expert and should be done with care.
            </para>
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.IShape.Relate(Spatial4n.Core.Shapes.IShape)">
            <summary>
            Describe the relationship between the two objects.  For example
            <list type="bullet">
              <item>this is <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.WITHIN"/> other</item>
              <item>this <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.CONTAINS"/> other</item>
              <item>this is <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.DISJOINT"/> other</item>
              <item>this <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.INTERSECTS"/> other</item>
            </list>
            Note that a <see cref="T:Spatial4n.Core.Shapes.IShape"/> implementation may choose to return <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.INTERSECTS"/> when the
            true answer is <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.WITHIN"/> or <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.CONTAINS"/> for performance reasons. If a shape does
            this then it <i>must</i> document when it does.  Ideally the shape will not
            do this approximation in all circumstances, just sometimes.
            <p />
            If the shapes are equal then the result is <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.CONTAINS"/> (preferred) or <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.WITHIN"/>.
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.IShape.BoundingBox">
            <summary>
            Get the bounding box for this <see cref="T:Spatial4n.Core.Shapes.IShape"/>. This means the shape is within the
            bounding box and that it touches each side of the rectangle.
            <p/>
            Postcondition: <c>this.BoundingBox.Relate(this) == SpatialRelation.CONTAINS</c>
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.IShape.HasArea">
            <summary>
            Does the shape have area?  This will be false for points and lines. It will
            also be false for shapes that normally have area but are constructed in a
            degenerate case as to not have area (e.g. a circle with 0 radius or
            rectangle with no height or no width).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Spatial4n.Core.Shapes.IShape.GetArea(Spatial4n.Core.Context.SpatialContext)">
            <summary>
            Calculates the area of the shape, in square-degrees. If ctx is null then
            simple Euclidean calculations will be used.  This figure can be an
            estimate.
            </summary>
        </member>
        <member name="P:Spatial4n.Core.Shapes.IShape.Center">
            <summary>
            Returns the center point of this shape. This is usually the same as
            <c>BoundingBox.Center</c> but it doesn't have to be.
            <para/>
            Postcondition: <c>this.Relate(this.Center) == SpatialContext.CONTAINS</c>
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.IShape.GetBuffered(System.Double,Spatial4n.Core.Context.SpatialContext)">
            <summary>
            Returns a buffered version of this shape.  The buffer is usually a
            rounded-corner buffer, although some shapes might buffer differently. This
            is an optional operation.
            </summary>
            <returns>Not null, and the returned shape should contain the current shape.</returns>
        </member>
        <member name="P:Spatial4n.Core.Shapes.IShape.IsEmpty">
            <summary>
            Shapes can be "empty", which is to say it exists nowhere. The underlying coordinates are
            typically NaN.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.IShape.Equals(System.Object)">
            <summary>
            The sub-classes of <see cref="T:Spatial4n.Core.Shapes.IShape"/> generally implement the
            same contract for <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/>
            amongst the same sub-interface type.  This means, for example, that multiple
            Point implementations of different classes are equal if they share the same x
            &amp; y.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Shapes.ShapeCollection">
            <summary>
            A collection of Shape objects, analogous to an OGC GeometryCollection. The
            implementation demands a List (with random access) so that the order can be
            retained if an application requires it, although logically it's treated as an
            unordered Set, mostly.
            <para>
            Ideally, <see cref="M:Spatial4n.Core.Shapes.ShapeCollection.Relate(Spatial4n.Core.Shapes.IShape)"/> should return the same result no matter what
            the shape order is, although the default implementation can be order
            dependent when the shapes overlap; see <see cref="M:Spatial4n.Core.Shapes.ShapeCollection.RelateContainsShortCircuits"/>.
            To improve performance slightly, the caller could order the shapes by
            largest first so that Relate() will have a greater chance of
            short-circuit'ing sooner.  As the Shape contract states; it may return
            intersects when the best answer is actually contains or within.If any shape
            intersects the provided shape then that is the answer.
            </para>
            <para>
            This implementation is not optimized for a large number of shapes; relate is
            O(N).  A more sophisticated implementation might do an R-Tree based on
            bbox'es, for example.
            </para>
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.ShapeCollection.#ctor(System.Collections.Generic.IList{Spatial4n.Core.Shapes.IShape},Spatial4n.Core.Context.SpatialContext)">
            <summary>
            WARNING: <paramref name="shapes"/> is copied by reference.
            </summary>
            <param name="shapes">Copied by reference! (make a defensive copy if caller modifies)</param>
            <param name="ctx"></param>
        </member>
        <member name="M:Spatial4n.Core.Shapes.ShapeCollection.RelateContainsShortCircuits">
            <summary>
            Called by <see cref="M:Spatial4n.Core.Shapes.ShapeCollection.Relate(Spatial4n.Core.Shapes.IShape)"/> to determine whether to return early if it finds
            <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.CONTAINS"/>, instead of checking the remaining shapes. It will do so without
            calling this method if the "other" shape is a Point.  If a remaining shape
            finds <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.INTERSECTS"/>, then <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.INTERSECTS"/> will be returned.  The only problem with
            this returning true is that if some of the shapes overlap, it's possible
            that the result of <see cref="M:Spatial4n.Core.Shapes.ShapeCollection.Relate(Spatial4n.Core.Shapes.IShape)"/> could be dependent on the order of the shapes,
            which could be unexpected / wrong depending on the application. The default
            implementation returns true because it probably doesn't matter.  If it
            does, a subclass could add a boolean flag that this method could return.
            That flag could be initialized to true only if the shapes are mutually
            disjoint.
            </summary>
            <seealso cref="M:Spatial4n.Core.Shapes.ShapeCollection.ComputeMutualDisjoint(System.Collections.Generic.IList{Spatial4n.Core.Shapes.IShape})"/>
        </member>
        <member name="M:Spatial4n.Core.Shapes.ShapeCollection.ComputeMutualDisjoint(System.Collections.Generic.IList{Spatial4n.Core.Shapes.IShape})">
            <summary>
            Computes whether the shapes are mutually disjoint. This is a utility method
            offered for use by a subclass implementing <see cref="M:Spatial4n.Core.Shapes.ShapeCollection.RelateContainsShortCircuits"/>.
            <b>Beware: this is an O(N^2) algorithm.</b>.  Consequently, consider safely
            assuming non-disjoint if shapes.Count > 10 or something.  And if all shapes
            are a <see cref="T:Spatial4n.Core.Shapes.IPoint"/> then the result of this method doesn't ultimately matter.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Shapes.SpatialRelation">
            <summary>
            The set of spatial relationships. Naming is consistent with OGC spec conventions as seen in SQL/MM and others.
            <para>
            No equality case.  If two <see cref="T:Spatial4n.Core.Shapes.IShape"/> instances are equal then the result might be <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.CONTAINS"/> (preferred) or <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.WITHIN"/>.  
            Client logic may have to be aware of this edge condition; Spatial4n testing certainly does.
            </para>
            <para></para>
            The "CONTAINS" and "WITHIN" wording here is inconsistent with OGC; these here map to OGC
            "COVERS" and "COVERED BY", respectively. The distinction is in the boundaries; in Spatial4n
            there is no boundary distinction -- boundaries are part of the shape as if it was an "interior",
            with respect to OGC's terminology.
            </summary>
        </member>
        <member name="F:Spatial4n.Core.Shapes.SpatialRelation.NOT_SET">
            <summary>
            Used in .NET for mimicking the ability to set an enum to null in Java.
            Set to zero explicitly to ensure it will be the default value for an 
            uninitialized SpatialRelation variable.
            </summary>
        </member>
        <member name="F:Spatial4n.Core.Shapes.SpatialRelation.WITHIN">
            <summary>
            The shape is within the target geometry. It's the converse of <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.CONTAINS"/>.
            Boundaries of shapes count too.  OGC specs refer to this relation as "COVERED BY";
            <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.WITHIN"/> is differentiated thereby not including boundaries.
            </summary>
        </member>
        <member name="F:Spatial4n.Core.Shapes.SpatialRelation.CONTAINS">
            <summary>
            The shape contains the target geometry. It's the converse of <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.WITHIN"/>.
            Boundaries of shapes count too.  OGC specs refer to this relation as "COVERS";
            <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.CONTAINS"/> is differentiated thereby not including boundaries.
            </summary>
        </member>
        <member name="F:Spatial4n.Core.Shapes.SpatialRelation.DISJOINT">
            <summary>
            The shape shares no point in common with the target shape.
            </summary>
        </member>
        <member name="F:Spatial4n.Core.Shapes.SpatialRelation.INTERSECTS">
            <summary>
            The shape shares some points/overlap with the target shape, and the relation is
            not more specifically <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.WITHIN"/> or <see cref="F:Spatial4n.Core.Shapes.SpatialRelation.CONTAINS"/>.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.SpatialRelationComparators.Transpose(Spatial4n.Core.Shapes.SpatialRelation)">
            <summary>
            Given the result of <c>shapeA.Relate(shapeB)</c>, transposing that
            result should yield the result of <c>shapeB.Relate(shapeA)</c>. There
            is a corner case is when the shapes are equal, in which case actually
            flipping the Relate() call will result in the same value -- either CONTAINS
            or WITHIN; this method can't possible check for that so the caller might
            have to.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.SpatialRelationComparators.Combine(Spatial4n.Core.Shapes.SpatialRelation,Spatial4n.Core.Shapes.SpatialRelation)">
            <summary>
            If you were to call aShape.Relate(bShape) and aShape.Relate(cShape), you 
            could call this to merge the intersect results as if bShape &amp; cShape were 
            combined into <see cref="T:Spatial4n.Core.Shapes.ShapeCollection"/>.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.SpatialRelationComparators.Intersects(Spatial4n.Core.Shapes.SpatialRelation)">
            <summary>
            Not DISJOINT, i.e. there is some sort of intersection.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Shapes.SpatialRelationComparators.Inverse(Spatial4n.Core.Shapes.SpatialRelation)">
            <summary>
            If <c>aShape.Relate(bShape)</c> is r, then <c>r.Inverse()</c>
            is <c>Inverse(aShape).Relate(bShape)</c> whereas
            <c>Inverse(shape)</c> is theoretically the opposite area covered by a
            shape, i.e. everywhere but where the shape is.
            <para/>
            Note that it's not commutative!  <code>WITHIN.inverse().inverse() !=
            WITHIN</code>.
            </summary>
        </member>
        <member name="T:Spatial4n.Core.Util.GeohashUtils">
            <summary>
             Utilities for encoding and decoding <a href="http://en.wikipedia.org/wiki/Geohash">geohashes</a>.
             <para/>
             This class isn't used by any other part of Spatial4n; it's included largely for convenience of
             software using Spatial4n. There are other open-source libraries that have more comprehensive
             geohash utilities but providing this one avoids an additional dependency for what's a small
             amount of code.  <c>If you're using Spatial4n just for this class, consider alternatives.</c>
             <para/>
             This code originally came from <a href="https://issues.apache.org/jira/browse/LUCENE-1512">
             Apache Lucene, LUCENE-1512</a>.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Util.GeohashUtils.EncodeLatLon(System.Double,System.Double)">
            <summary>
            Encodes the given latitude and longitude into a geohash
            </summary>
            <param name="latitude">Latitude to encode</param>
            <param name="longitude">Longitude to encode</param>
            <returns>Geohash encoding of the longitude and latitude</returns>
        </member>
        <member name="M:Spatial4n.Core.Util.GeohashUtils.EncodeLatLon(System.Double,System.Double,System.Int32)">
            <summary>
            Encodes the given latitude and longitude into a geohash
            </summary>
            <param name="latitude">Latitude to encode</param>
            <param name="longitude">Longitude to encode</param>
            <param name="precision"></param>
            <returns>Geohash encoding of the longitude and latitude</returns>
        </member>
        <member name="M:Spatial4n.Core.Util.GeohashUtils.Decode(System.String,Spatial4n.Core.Context.SpatialContext)">
            <summary>
            Decodes the given geohash into a latitude and longitude
            </summary>
            <param name="geohash">Geohash to deocde</param>
            <param name="ctx"></param>
            <returns>Array with the latitude at index 0, and longitude at index 1</returns>
        </member>
        <member name="M:Spatial4n.Core.Util.GeohashUtils.DecodeBoundary(System.String,Spatial4n.Core.Context.SpatialContext)">
            <summary>
            Returns min-max lat, min-max lon.
            </summary>
        </member>
        <member name="M:Spatial4n.Core.Util.GeohashUtils.GetSubGeohashes(System.String)">
            <summary>Array of geohashes 1 level below the baseGeohash. Sorted.</summary>
        </member>
        <member name="M:Spatial4n.Core.Util.GeohashUtils.LookupHashLenForWidthHeight(System.Double,System.Double)">
            <summary>
            Return the shortest geohash length that will have a width &amp; height >= specified arguments.
            </summary>
        </member>
        <member name="F:Spatial4n.Core.Util.GeohashUtils.hashLenToLatHeight">
            See the table at http://en.wikipedia.org/wiki/Geohash 
        </member>
    </members>
</doc>
